function state = evolveState(adjMatrix, state)
% evolveState - Evolve the state of the graph based on a logical function.

% Given an adjancency matrix representing the connectivity of a
% graph and a vector of binary digits corresponding to the state of each
% node in the graph, calculate the state that results from applying
% the given logical function to each node taking the state of its
% incoming edges as inputs.  

% As it is coded, evolveState has a hard-coded logical function F
% that each node executes.  However, this function is implemented
% as a vector of binary values representing the truth table for an
% arbitrary logical function.  In this way, any logical function
% could be encoded by supplying a different binary vector, with the
% one present simply an arbitrary choice.  This flexibility could
% be taken advantage of if evolveState were also to take a truth
% table as a third argument, but due to the limitations of the
% assigment, is content to be hard-coded.

% inputs:
%   adjMatrix - A matrix representing the edges in a graph.  The
%     edges going out of a node are a row, with each node the edge or
%     edges are going to being the column for that row.  
%   state - a vector of binary digits representing the state of
%     each node in the graph.

% output: 
%   state - the state as resulting from applying the logical
%     function to the values of the nodes for the incoming edges.  

% example: 
%   graph = createDirectedGraph(5, 10)
%   state = randState(5)
%   state = evolveState(graph, state)

%   state = 
%           [ 1 1 1 1 0 ]     (or similar) 

% ---------------------------------------------------
% author:  Ryan Spangler
% email:  ryan.spangler@gmail.com
% Portland State University
% -----------------------------

% BEGIN CODE

% Initialize the length of the state so we don't have to keep
% repeating it over and over again.
L = length(state);

% Find the maximum number of potential arguments to the logical
% function by finding the node with the maximum number of incoming
% edges.  This makes the function bounded in practice, while still
% able to take on any size.
max_args = max(sum(adjMatrix));

% Calculate the powers of two so decimate does not have to generate
% these same values over and over.
powers_of_two = arrayfun(@(n) 2^n, 0:max_args);

% Decimate converts a list of binary digits into an integer.
decimate = @(binary) sum(binary .* powers_of_two(1:length(binary)));

% Padding to ensure the access to the logical function does not
% exceed the number of elements in the truth table given.
padding = zeros(1, 2^(max_args + 1));

% A truth table is represented as a vector of binary values.  Each
% binary value in the truth table corresponds to a particular input 
% configuration. Since a truth table has a result for every
% possible input configuration, the input configurations themselves
% can be omitted in the representation as long as the 1xN binary
% vector is taken to be in some enumerable order.  In this case the
% table is indexed by the input vector being converted to a single
% value, with each successive element in the input vector standing
% for the next power of two, which is either present or not
% depending on whether that element in the input vector is on or
% off.  

% This is a hardcoded representation of a truth table.  
% It is just meant to be an example, as any arbitrary truth table
% could be provided to evolveState if an argument for it was added.
truth_table = [ 1 0 0 0 1 0 1 1 1 1 1 0 1 0 0 1 1 0 0 ...
                1 0 1 0 1 1 1 1 0 1 1 1 0 1 0 1 0 0 1 ...
                0 1 1 1 1 1 0 1 1 1 0 1 1 1 1 0 0 0 0 ...
                1 1 0 1 0 1 1 ];

% Converts a truth table into a logical function.
logic = @(truth) @(n) truth(n);

% Take our particular truth table and create a logical function
% based on its representation.  This is the function that will be
% executed by each node given the vector of the states of its
% inputs to determine what the next state of the node will be.
F = logic([truth_table, padding]);

% Translate converts a column from the adjacency matrix into a
% vector containing the corresponding state for each element in the
% column repeated the number of times given by the value of that element.
translate = @(column) arrayfun(@(n) repmat(state(n), 1, column(n)), ...
                               1:L, 'UniformOutput', 0);

% Join concatenates all of the cells generated by the translate
% function and treats them as binary digits, converting them to
% integers with decimate so that the result may be used as an index
% into the truth table to determine the next state.
join = @(cells) decimate(horzcat(cells{:}));

% Finally, the next state is generated by calling translate on
% each column and then joining the result.  In the algorithm, each
% row in the adjacency matrix is distilled to an index into the
% logical function's truth table.  
state = arrayfun(@(n) F(join(translate(adjMatrix(:, n))) + 1), 1:L);

% END CODE 